// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: piggy.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const createPiggy = `-- name: CreatePiggy :one
INSERT INTO "piggy" (
  "address", "from_address", "profile_address", "created_at", "added_at", "unlocks_at", "name"
) VALUES ($1, $2, $3, $4, now(), $5, $6) RETURNING address, from_address, profile_address, created_at, added_at, unlocks_at, name
`

type CreatePiggyParams struct {
	Address        string
	FromAddress    string
	ProfileAddress string
	CreatedAt      time.Time
	UnlocksAt      time.Time
	Name           sql.NullString
}

func (q *Queries) CreatePiggy(ctx context.Context, arg CreatePiggyParams) (Piggy, error) {
	row := q.db.QueryRowContext(ctx, createPiggy,
		arg.Address,
		arg.FromAddress,
		arg.ProfileAddress,
		arg.CreatedAt,
		arg.UnlocksAt,
		arg.Name,
	)
	var i Piggy
	err := row.Scan(
		&i.Address,
		&i.FromAddress,
		&i.ProfileAddress,
		&i.CreatedAt,
		&i.AddedAt,
		&i.UnlocksAt,
		&i.Name,
	)
	return i, err
}

const getPiggies = `-- name: GetPiggies :many
SELECT address, from_address, profile_address, created_at, added_at, unlocks_at, name FROM "piggy"
WHERE profile_address = $1
`

func (q *Queries) GetPiggies(ctx context.Context, profileAddress string) ([]Piggy, error) {
	rows, err := q.db.QueryContext(ctx, getPiggies, profileAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Piggy
	for rows.Next() {
		var i Piggy
		if err := rows.Scan(
			&i.Address,
			&i.FromAddress,
			&i.ProfileAddress,
			&i.CreatedAt,
			&i.AddedAt,
			&i.UnlocksAt,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPiggy = `-- name: GetPiggy :one
SELECT address, from_address, profile_address, created_at, added_at, unlocks_at, name FROM "piggy"
WHERE address = $1
`

func (q *Queries) GetPiggy(ctx context.Context, address string) (Piggy, error) {
	row := q.db.QueryRowContext(ctx, getPiggy, address)
	var i Piggy
	err := row.Scan(
		&i.Address,
		&i.FromAddress,
		&i.ProfileAddress,
		&i.CreatedAt,
		&i.AddedAt,
		&i.UnlocksAt,
		&i.Name,
	)
	return i, err
}

const getPiggyFromName = `-- name: GetPiggyFromName :one
SELECT address, from_address, profile_address, created_at, added_at, unlocks_at, name FROM "piggy"
WHERE name = $1
`

func (q *Queries) GetPiggyFromName(ctx context.Context, name sql.NullString) (Piggy, error) {
	row := q.db.QueryRowContext(ctx, getPiggyFromName, name)
	var i Piggy
	err := row.Scan(
		&i.Address,
		&i.FromAddress,
		&i.ProfileAddress,
		&i.CreatedAt,
		&i.AddedAt,
		&i.UnlocksAt,
		&i.Name,
	)
	return i, err
}

const getPiggyFromProfileAddress = `-- name: GetPiggyFromProfileAddress :one
SELECT address, from_address, profile_address, created_at, added_at, unlocks_at, name FROM "piggy"
WHERE profile_address = $1
`

func (q *Queries) GetPiggyFromProfileAddress(ctx context.Context, profileAddress string) (Piggy, error) {
	row := q.db.QueryRowContext(ctx, getPiggyFromProfileAddress, profileAddress)
	var i Piggy
	err := row.Scan(
		&i.Address,
		&i.FromAddress,
		&i.ProfileAddress,
		&i.CreatedAt,
		&i.AddedAt,
		&i.UnlocksAt,
		&i.Name,
	)
	return i, err
}

const updatePiggy = `-- name: UpdatePiggy :one
UPDATE "piggy"
SET 
  name = $1
WHERE address = $2 RETURNING address, from_address, profile_address, created_at, added_at, unlocks_at, name
`

type UpdatePiggyParams struct {
	Name    sql.NullString
	Address string
}

func (q *Queries) UpdatePiggy(ctx context.Context, arg UpdatePiggyParams) (Piggy, error) {
	row := q.db.QueryRowContext(ctx, updatePiggy, arg.Name, arg.Address)
	var i Piggy
	err := row.Scan(
		&i.Address,
		&i.FromAddress,
		&i.ProfileAddress,
		&i.CreatedAt,
		&i.AddedAt,
		&i.UnlocksAt,
		&i.Name,
	)
	return i, err
}
